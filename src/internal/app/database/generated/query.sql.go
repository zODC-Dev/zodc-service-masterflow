// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuthor = `-- name: CreateAuthor :one
INSERT INTO authors (
  name, bio
) VALUES (
  $1, $2
)
RETURNING id, name, bio
`

type CreateAuthorParams struct {
	Name string      `db:"name" json:"name"`
	Bio  pgtype.Text `db:"bio" json:"bio"`
}

func (q *Queries) CreateAuthor(ctx context.Context, arg *CreateAuthorParams) (*Author, error) {
	row := q.db.QueryRow(ctx, createAuthor, arg.Name, arg.Bio)
	var i Author
	err := row.Scan(&i.ID, &i.Name, &i.Bio)
	return &i, err
}

const createForm = `-- name: CreateForm :one
INSERT INTO forms (
    file_name,
    title,
    function,
    version,
    template,
    datasheet,
    description,
    decoration
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, created_at, updated_at, deleted_at, file_name, title, function, version, template, datasheet, description, decoration
`

type CreateFormParams struct {
	FileName    string          `db:"file_name" json:"fileName"`
	Title       string          `db:"title" json:"title"`
	Function    string          `db:"function" json:"function"`
	Version     int32           `db:"version" json:"version"`
	Template    pgtype.Text     `db:"template" json:"template"`
	Datasheet   json.RawMessage `db:"datasheet" json:"datasheet"`
	Description string          `db:"description" json:"description"`
	Decoration  string          `db:"decoration" json:"decoration"`
}

func (q *Queries) CreateForm(ctx context.Context, arg *CreateFormParams) (*Form, error) {
	row := q.db.QueryRow(ctx, createForm,
		arg.FileName,
		arg.Title,
		arg.Function,
		arg.Version,
		arg.Template,
		arg.Datasheet,
		arg.Description,
		arg.Decoration,
	)
	var i Form
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.FileName,
		&i.Title,
		&i.Function,
		&i.Version,
		&i.Template,
		&i.Datasheet,
		&i.Description,
		&i.Decoration,
	)
	return &i, err
}

const createFormField = `-- name: CreateFormField :one
INSERT INTO form_fields (
    field_id,
    icon,
    title,
    category,
    field_name,
    field_type,
    required,
    advanced_options,
    col_num,
    form_id
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, created_at, updated_at, deleted_at, field_id, icon, title, category, field_name, field_type, required, advanced_options, col_num, form_id
`

type CreateFormFieldParams struct {
	FieldID         string          `db:"field_id" json:"fieldId"`
	Icon            string          `db:"icon" json:"icon"`
	Title           string          `db:"title" json:"title"`
	Category        string          `db:"category" json:"category"`
	FieldName       string          `db:"field_name" json:"fieldName"`
	FieldType       string          `db:"field_type" json:"fieldType"`
	Required        bool            `db:"required" json:"required"`
	AdvancedOptions json.RawMessage `db:"advanced_options" json:"advancedOptions"`
	ColNum          int32           `db:"col_num" json:"colNum"`
	FormID          int32           `db:"form_id" json:"formId"`
}

func (q *Queries) CreateFormField(ctx context.Context, arg *CreateFormFieldParams) (*FormField, error) {
	row := q.db.QueryRow(ctx, createFormField,
		arg.FieldID,
		arg.Icon,
		arg.Title,
		arg.Category,
		arg.FieldName,
		arg.FieldType,
		arg.Required,
		arg.AdvancedOptions,
		arg.ColNum,
		arg.FormID,
	)
	var i FormField
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.FieldID,
		&i.Icon,
		&i.Title,
		&i.Category,
		&i.FieldName,
		&i.FieldType,
		&i.Required,
		&i.AdvancedOptions,
		&i.ColNum,
		&i.FormID,
	)
	return &i, err
}

const createMutiFormFields = `-- name: CreateMutiFormFields :many
INSERT INTO form_fields (
    field_id,
    icon,
    title,
    category,
    field_name,
    field_type,
    required,
    advanced_options,
    col_num,
    form_id
)
SELECT
    unnest($1::text[]) as field_id,
    unnest($2::text[]) as icon,
    unnest($3::text[]) as title,
    unnest($4::text[]) as category,
    unnest($5::text[]) as field_name,
    unnest($6::text[]) as field_type,
    unnest($7::boolean[]) as required,
    unnest($8::jsonb[]) as advanced_options,
    unnest($9::int[]) as col_num,
    unnest($10::int[]) as form_id
RETURNING id, created_at, updated_at, deleted_at, field_id, icon, title, category, field_name, field_type, required, advanced_options, col_num, form_id
`

type CreateMutiFormFieldsParams struct {
	FieldIds         []string          `db:"field_ids" json:"fieldIds"`
	Icons            []string          `db:"icons" json:"icons"`
	Titles           []string          `db:"titles" json:"titles"`
	Categories       []string          `db:"categories" json:"categories"`
	FieldNamess      []string          `db:"field_namess" json:"fieldNamess"`
	FieldTypes       []string          `db:"field_types" json:"fieldTypes"`
	Requireds        []bool            `db:"requireds" json:"requireds"`
	AdvancedOptionss []json.RawMessage `db:"advanced_optionss" json:"advancedOptionss"`
	ColNums          []int32           `db:"col_nums" json:"colNums"`
	FormIds          []int32           `db:"form_ids" json:"formIds"`
}

func (q *Queries) CreateMutiFormFields(ctx context.Context, arg *CreateMutiFormFieldsParams) ([]*FormField, error) {
	rows, err := q.db.Query(ctx, createMutiFormFields,
		arg.FieldIds,
		arg.Icons,
		arg.Titles,
		arg.Categories,
		arg.FieldNamess,
		arg.FieldTypes,
		arg.Requireds,
		arg.AdvancedOptionss,
		arg.ColNums,
		arg.FormIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FormField{}
	for rows.Next() {
		var i FormField
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.FieldID,
			&i.Icon,
			&i.Title,
			&i.Category,
			&i.FieldName,
			&i.FieldType,
			&i.Required,
			&i.AdvancedOptions,
			&i.ColNum,
			&i.FormID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteAuthor = `-- name: DeleteAuthor :exec
DELETE FROM authors
WHERE id = $1
`

func (q *Queries) DeleteAuthor(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAuthor, id)
	return err
}

const findAllForms = `-- name: FindAllForms :many
SELECT forms.id, forms.created_at, forms.updated_at, forms.deleted_at, forms.file_name, forms.title, forms.function, forms.version, forms.template, forms.datasheet, forms.description, forms.decoration, form_fields.id, form_fields.created_at, form_fields.updated_at, form_fields.deleted_at, form_fields.field_id, form_fields.icon, form_fields.title, form_fields.category, form_fields.field_name, form_fields.field_type, form_fields.required, form_fields.advanced_options, form_fields.col_num, form_fields.form_id
FROM forms
LEFT JOIN form_fields ON forms.id = form_fields.form_id
`

type FindAllFormsRow struct {
	ID          int32            `db:"id" json:"id"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"createdAt"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updatedAt"`
	DeletedAt   pgtype.Timestamp `db:"deleted_at" json:"deletedAt"`
	FileName    string           `db:"file_name" json:"fileName"`
	Title       string           `db:"title" json:"title"`
	Function    string           `db:"function" json:"function"`
	Version     int32            `db:"version" json:"version"`
	Template    pgtype.Text      `db:"template" json:"template"`
	Datasheet   json.RawMessage  `db:"datasheet" json:"datasheet"`
	Description string           `db:"description" json:"description"`
	Decoration  string           `db:"decoration" json:"decoration"`
	FormField   FormField        `db:"form_field" json:"formField"`
}

func (q *Queries) FindAllForms(ctx context.Context) ([]*FindAllFormsRow, error) {
	rows, err := q.db.Query(ctx, findAllForms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FindAllFormsRow{}
	for rows.Next() {
		var i FindAllFormsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.FileName,
			&i.Title,
			&i.Function,
			&i.Version,
			&i.Template,
			&i.Datasheet,
			&i.Description,
			&i.Decoration,
			&i.FormField.ID,
			&i.FormField.CreatedAt,
			&i.FormField.UpdatedAt,
			&i.FormField.DeletedAt,
			&i.FormField.FieldID,
			&i.FormField.Icon,
			&i.FormField.Title,
			&i.FormField.Category,
			&i.FormField.FieldName,
			&i.FormField.FieldType,
			&i.FormField.Required,
			&i.FormField.AdvancedOptions,
			&i.FormField.ColNum,
			&i.FormField.FormID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthor = `-- name: GetAuthor :one
SELECT id, name, bio FROM authors
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAuthor(ctx context.Context, id int64) (*Author, error) {
	row := q.db.QueryRow(ctx, getAuthor, id)
	var i Author
	err := row.Scan(&i.ID, &i.Name, &i.Bio)
	return &i, err
}

const listAuthors = `-- name: ListAuthors :many
SELECT id, name, bio FROM authors
ORDER BY name
`

func (q *Queries) ListAuthors(ctx context.Context) ([]*Author, error) {
	rows, err := q.db.Query(ctx, listAuthors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Author{}
	for rows.Next() {
		var i Author
		if err := rows.Scan(&i.ID, &i.Name, &i.Bio); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAuthor = `-- name: UpdateAuthor :exec
UPDATE authors
  set name = $2,
  bio = $3
WHERE id = $1
`

type UpdateAuthorParams struct {
	ID   int64       `db:"id" json:"id"`
	Name string      `db:"name" json:"name"`
	Bio  pgtype.Text `db:"bio" json:"bio"`
}

func (q *Queries) UpdateAuthor(ctx context.Context, arg *UpdateAuthorParams) error {
	_, err := q.db.Exec(ctx, updateAuthor, arg.ID, arg.Name, arg.Bio)
	return err
}
